/**
 * Delve Taxonomy - TypeScript/JavaScript Client SDK
 *
 * A thin client for the Delve Taxonomy REST API that provides
 * AI-powered taxonomy generation using LLMs.
 *
 * @example
 * ```typescript
 * import { Delve } from '@delve-ai/taxonomy';
 *
 * const delve = new Delve({ baseUrl: 'http://localhost:8000' });
 *
 * const result = await delve.generateFromArray(
 *   [{ text: 'Customer complaint about billing' }, { text: 'Question about features' }],
 *   { textField: 'text', config: { maxNumClusters: 5 } }
 * );
 *
 * console.log(result.taxonomy);
 * ```
 */

// ============================================================================
// Types
// ============================================================================

/**
 * Taxonomy category generated by Delve
 */
export interface TaxonomyCategory {
  /** Unique category identifier */
  id: string;
  /** Human-readable category name */
  name: string;
  /** Detailed description of the category */
  description: string;
}

/**
 * Document for taxonomy processing
 */
export interface Document {
  /** Unique document identifier */
  id: string;
  /** Document text content */
  content: string;
  /** Generated summary */
  summary?: string;
  /** Explanation for category assignment */
  explanation?: string;
  /** Assigned category ID */
  category?: string;
}

/**
 * Document with category assignment
 */
export interface LabeledDocument extends Document {
  /** Assigned category ID */
  category: string;
  /** Confidence score (0-1) if classifier was used */
  confidence?: number;
  /** Labeling method: 'llm' or 'classifier' */
  labeledBy?: 'llm' | 'classifier';
}

/**
 * Classifier performance metrics
 */
export interface ClassifierMetrics {
  /** Accuracy on training set */
  trainAccuracy: number;
  /** Accuracy on test set */
  testAccuracy: number;
  /** F1 score on training set */
  trainF1: number;
  /** F1 score on test set */
  testF1: number;
}

/**
 * Metadata about the taxonomy generation run
 */
export interface RunMetadata {
  /** Total documents processed */
  totalDocuments: number;
  /** Documents used for taxonomy discovery */
  sampledDocuments: number;
  /** Documents labeled by LLM */
  llmLabeledCount: number;
  /** Documents labeled by classifier */
  classifierLabeledCount: number;
  /** Documents skipped */
  skippedDocumentCount: number;
  /** Classifier metrics if used */
  classifierMetrics?: ClassifierMetrics;
  /** Processing duration in milliseconds */
  durationMs: number;
  /** Start timestamp ISO format */
  startedAt: string;
  /** Completion timestamp ISO format */
  completedAt: string;
  /** Processing warnings */
  warnings: string[];
}

/**
 * Configuration for taxonomy generation
 */
export interface DelveConfig {
  /** Main LLM model (default: claude-sonnet-4-5-20250929) */
  model?: string;
  /** Fast LLM for summarization (default: claude-haiku-4-5-20251001) */
  fastLlm?: string;
  /** Documents to sample for taxonomy discovery (default: 100) */
  sampleSize?: number;
  /** Batch size for iterative refinement (default: 200) */
  batchSize?: number;
  /** Description of the use case/domain */
  useCase?: string;
  /** Maximum taxonomy categories (default: 5) */
  maxNumClusters?: number;
  /** Embedding model for classifier (default: text-embedding-3-large) */
  embeddingModel?: string;
  /** Confidence threshold for classifier (0-1, default: 0) */
  classifierConfidenceThreshold?: number;
  /** Predefined taxonomy (skip discovery) */
  predefinedTaxonomy?: TaxonomyCategory[];
}

/**
 * Result from taxonomy generation
 */
export interface DelveResult {
  /** Generated taxonomy categories */
  taxonomy: TaxonomyCategory[];
  /** All labeled documents */
  labeledDocuments: LabeledDocument[];
  /** Run metadata and statistics */
  metadata: RunMetadata;
  /** Configuration used */
  config: DelveConfig;
}

/**
 * Result from document labeling
 */
export interface LabelResult {
  /** Labeled documents */
  labeledDocuments: LabeledDocument[];
  /** Labeling metadata */
  metadata: Record<string, unknown>;
}

/**
 * Client configuration
 */
export interface DelveClientConfig {
  /** Base URL of the Delve API (default: http://localhost:8000) */
  baseUrl?: string;
  /** Custom fetch implementation (for Node.js < 18 or custom handling) */
  fetch?: typeof fetch;
  /** Default headers to include in requests */
  headers?: Record<string, string>;
  /** Request timeout in milliseconds (default: 300000 = 5 min) */
  timeout?: number;
}

/**
 * Options for generating from array
 */
export interface GenerateFromArrayOptions {
  /** Field containing text content (default: 'text') */
  textField?: string;
  /** Field containing document IDs */
  idField?: string;
  /** Generation configuration */
  config?: DelveConfig;
}

/**
 * Options for generating from documents
 */
export interface GenerateFromDocsOptions {
  /** Generation configuration */
  config?: DelveConfig;
}

/**
 * Options for generating from CSV
 */
export interface GenerateFromCSVOptions {
  /** Column containing text content */
  textColumn: string;
  /** Column containing document IDs */
  idColumn?: string;
  /** CSV delimiter (default: ',') */
  delimiter?: string;
  /** Generation configuration */
  config?: DelveConfig;
}

/**
 * Options for generating from JSON
 */
export interface GenerateFromJSONOptions {
  /** Field containing text content (default: 'text') */
  textField?: string;
  /** Field containing document IDs */
  idField?: string;
  /** JSONPath to extract documents */
  jsonPath?: string;
  /** Generation configuration */
  config?: DelveConfig;
}

/**
 * Options for labeling documents
 */
export interface LabelOptions {
  /** Configuration for labeling */
  config?: DelveConfig;
}

// ============================================================================
// Error Classes
// ============================================================================

/**
 * Error thrown by the Delve client
 */
export class DelveError extends Error {
  /** HTTP status code */
  status?: number;
  /** Error details from API */
  details?: Record<string, unknown>;

  constructor(message: string, status?: number, details?: Record<string, unknown>) {
    super(message);
    this.name = 'DelveError';
    this.status = status;
    this.details = details;
  }
}

// ============================================================================
// Client
// ============================================================================

/**
 * Delve Taxonomy Client
 *
 * A client for interacting with the Delve Taxonomy REST API.
 *
 * @example
 * ```typescript
 * const delve = new Delve({ baseUrl: 'http://localhost:8000' });
 *
 * // Generate taxonomy from array of objects
 * const result = await delve.generateFromArray(data, { textField: 'message' });
 *
 * // Label documents with existing taxonomy
 * const labeled = await delve.labelDocuments(docs, taxonomy);
 * ```
 */
export class Delve {
  private baseUrl: string;
  private fetchFn: typeof fetch;
  private headers: Record<string, string>;
  private timeout: number;

  constructor(config: DelveClientConfig = {}) {
    this.baseUrl = (config.baseUrl || 'http://localhost:8000').replace(/\/$/, '');
    this.fetchFn = config.fetch || globalThis.fetch;
    this.headers = {
      'Content-Type': 'application/json',
      ...config.headers,
    };
    this.timeout = config.timeout || 300000; // 5 minutes default

    if (!this.fetchFn) {
      throw new DelveError(
        'fetch is not available. Please provide a fetch implementation or use Node.js 18+.'
      );
    }
  }

  /**
   * Make a request to the API
   */
  private async request<T>(
    method: string,
    path: string,
    body?: unknown
  ): Promise<T> {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), this.timeout);

    try {
      const response = await this.fetchFn(`${this.baseUrl}${path}`, {
        method,
        headers: this.headers,
        body: body ? JSON.stringify(body) : undefined,
        signal: controller.signal,
      });

      clearTimeout(timeoutId);

      if (!response.ok) {
        let errorData: Record<string, unknown> = {};
        try {
          errorData = await response.json();
        } catch {
          // Ignore JSON parse errors
        }

        throw new DelveError(
          (errorData.detail as string) || (errorData.message as string) || `HTTP ${response.status}`,
          response.status,
          errorData
        );
      }

      return response.json();
    } catch (error) {
      clearTimeout(timeoutId);

      if (error instanceof DelveError) {
        throw error;
      }

      if (error instanceof Error) {
        if (error.name === 'AbortError') {
          throw new DelveError(`Request timeout after ${this.timeout}ms`);
        }
        throw new DelveError(error.message);
      }

      throw new DelveError('Unknown error occurred');
    }
  }

  /**
   * Check API health
   */
  async health(): Promise<{ status: string; version: string }> {
    return this.request('GET', '/health');
  }

  /**
   * Generate taxonomy from an array of data objects
   *
   * @param data - Array of objects containing text data
   * @param options - Generation options
   * @returns Taxonomy generation result
   *
   * @example
   * ```typescript
   * const result = await delve.generateFromArray(
   *   [
   *     { text: 'How do I reset my password?' },
   *     { text: 'Billing inquiry about invoice' },
   *   ],
   *   { textField: 'text', config: { maxNumClusters: 5 } }
   * );
   * ```
   */
  async generateFromArray(
    data: Record<string, unknown>[],
    options: GenerateFromArrayOptions = {}
  ): Promise<DelveResult> {
    const response = await this.request<ApiDelveResult>('POST', '/generate/array', {
      data,
      text_field: options.textField || 'text',
      id_field: options.idField,
      config: this.transformConfig(options.config),
    });

    return this.transformResult(response);
  }

  /**
   * Generate taxonomy from pre-formatted documents
   *
   * @param documents - Array of Document objects
   * @param options - Generation options
   * @returns Taxonomy generation result
   *
   * @example
   * ```typescript
   * const result = await delve.generateFromDocuments([
   *   { id: '1', content: 'Customer support inquiry' },
   *   { id: '2', content: 'Technical question' },
   * ]);
   * ```
   */
  async generateFromDocuments(
    documents: Document[],
    options: GenerateFromDocsOptions = {}
  ): Promise<DelveResult> {
    const response = await this.request<ApiDelveResult>('POST', '/generate/documents', {
      documents,
      config: this.transformConfig(options.config),
    });

    return this.transformResult(response);
  }

  /**
   * Generate taxonomy from CSV content
   *
   * @param csvContent - CSV file content as string
   * @param options - Generation options (textColumn required)
   * @returns Taxonomy generation result
   *
   * @example
   * ```typescript
   * const csv = `id,message\n1,"How do I login?"\n2,"Refund request"`;
   * const result = await delve.generateFromCSV(csv, {
   *   textColumn: 'message',
   *   idColumn: 'id',
   * });
   * ```
   */
  async generateFromCSV(
    csvContent: string,
    options: GenerateFromCSVOptions
  ): Promise<DelveResult> {
    const response = await this.request<ApiDelveResult>('POST', '/generate/csv', {
      csv_content: csvContent,
      text_column: options.textColumn,
      id_column: options.idColumn,
      delimiter: options.delimiter || ',',
      config: this.transformConfig(options.config),
    });

    return this.transformResult(response);
  }

  /**
   * Generate taxonomy from JSON content
   *
   * @param jsonContent - JSON or JSONL content as string
   * @param options - Generation options
   * @returns Taxonomy generation result
   *
   * @example
   * ```typescript
   * const json = JSON.stringify([
   *   { text: 'Question about pricing' },
   *   { text: 'Bug report' },
   * ]);
   * const result = await delve.generateFromJSON(json, { textField: 'text' });
   * ```
   */
  async generateFromJSON(
    jsonContent: string,
    options: GenerateFromJSONOptions = {}
  ): Promise<DelveResult> {
    const response = await this.request<ApiDelveResult>('POST', '/generate/json', {
      json_content: jsonContent,
      text_field: options.textField || 'text',
      id_field: options.idField,
      json_path: options.jsonPath,
      config: this.transformConfig(options.config),
    });

    return this.transformResult(response);
  }

  /**
   * Label documents using an existing taxonomy
   *
   * @param documents - Documents to label
   * @param taxonomy - Taxonomy to use for labeling
   * @param options - Labeling options
   * @returns Labeled documents
   *
   * @example
   * ```typescript
   * const labeled = await delve.labelDocuments(
   *   [{ id: '1', content: 'New support ticket' }],
   *   existingTaxonomy
   * );
   * ```
   */
  async labelDocuments(
    documents: Document[],
    taxonomy: TaxonomyCategory[],
    options: LabelOptions = {}
  ): Promise<LabelResult> {
    const response = await this.request<ApiLabelResult>('POST', '/label', {
      documents,
      taxonomy,
      config: this.transformConfig(options.config),
    });

    return {
      labeledDocuments: response.labeled_documents.map(this.transformLabeledDocument),
      metadata: response.metadata,
    };
  }

  /**
   * Transform config to API format (snake_case)
   */
  private transformConfig(config?: DelveConfig): Record<string, unknown> | undefined {
    if (!config) return undefined;

    return {
      model: config.model,
      fast_llm: config.fastLlm,
      sample_size: config.sampleSize,
      batch_size: config.batchSize,
      use_case: config.useCase,
      max_num_clusters: config.maxNumClusters,
      embedding_model: config.embeddingModel,
      classifier_confidence_threshold: config.classifierConfidenceThreshold,
      predefined_taxonomy: config.predefinedTaxonomy,
    };
  }

  /**
   * Transform API result to SDK format (camelCase)
   */
  private transformResult(response: ApiDelveResult): DelveResult {
    return {
      taxonomy: response.taxonomy,
      labeledDocuments: response.labeled_documents.map(this.transformLabeledDocument),
      metadata: {
        totalDocuments: response.metadata.total_documents,
        sampledDocuments: response.metadata.sampled_documents,
        llmLabeledCount: response.metadata.llm_labeled_count,
        classifierLabeledCount: response.metadata.classifier_labeled_count,
        skippedDocumentCount: response.metadata.skipped_document_count,
        classifierMetrics: response.metadata.classifier_metrics
          ? {
              trainAccuracy: response.metadata.classifier_metrics.train_accuracy,
              testAccuracy: response.metadata.classifier_metrics.test_accuracy,
              trainF1: response.metadata.classifier_metrics.train_f1,
              testF1: response.metadata.classifier_metrics.test_f1,
            }
          : undefined,
        durationMs: response.metadata.duration_ms,
        startedAt: response.metadata.started_at,
        completedAt: response.metadata.completed_at,
        warnings: response.metadata.warnings,
      },
      config: {
        model: response.config.model,
        fastLlm: response.config.fast_llm,
        sampleSize: response.config.sample_size,
        batchSize: response.config.batch_size,
        useCase: response.config.use_case,
        maxNumClusters: response.config.max_num_clusters,
        embeddingModel: response.config.embedding_model,
        classifierConfidenceThreshold: response.config.classifier_confidence_threshold,
        predefinedTaxonomy: response.config.predefined_taxonomy,
      },
    };
  }

  /**
   * Transform labeled document from API format
   */
  private transformLabeledDocument(doc: ApiLabeledDocument): LabeledDocument {
    return {
      id: doc.id,
      content: doc.content,
      summary: doc.summary,
      explanation: doc.explanation,
      category: doc.category,
      confidence: doc.confidence,
      labeledBy: doc.labeled_by as 'llm' | 'classifier' | undefined,
    };
  }
}

// ============================================================================
// Internal API Types (snake_case from API)
// ============================================================================

interface ApiLabeledDocument {
  id: string;
  content: string;
  summary?: string;
  explanation?: string;
  category: string;
  confidence?: number;
  labeled_by?: string;
}

interface ApiClassifierMetrics {
  train_accuracy: number;
  test_accuracy: number;
  train_f1: number;
  test_f1: number;
}

interface ApiRunMetadata {
  total_documents: number;
  sampled_documents: number;
  llm_labeled_count: number;
  classifier_labeled_count: number;
  skipped_document_count: number;
  classifier_metrics?: ApiClassifierMetrics;
  duration_ms: number;
  started_at: string;
  completed_at: string;
  warnings: string[];
}

interface ApiConfig {
  model?: string;
  fast_llm?: string;
  sample_size?: number;
  batch_size?: number;
  use_case?: string;
  max_num_clusters?: number;
  embedding_model?: string;
  classifier_confidence_threshold?: number;
  predefined_taxonomy?: TaxonomyCategory[];
}

interface ApiDelveResult {
  taxonomy: TaxonomyCategory[];
  labeled_documents: ApiLabeledDocument[];
  metadata: ApiRunMetadata;
  config: ApiConfig;
}

interface ApiLabelResult {
  labeled_documents: ApiLabeledDocument[];
  metadata: Record<string, unknown>;
}

// ============================================================================
// Default Export
// ============================================================================

export default Delve;
